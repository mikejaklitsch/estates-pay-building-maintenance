# Location-Based Building Maintenance - Context Prompt

## Project Overview

**Mod:** Estates Pay Building Maintenance (EPBM) for Europa Universalis V
**Branch:** `location-based-maintenance`
**Base game path:** `/mnt/c/SteamLibrary/steamapps/common/Europa Universalis V`
**Mod path:** `/mnt/c/Users/Mjaklitsch/Documents/Paradox Interactive/Europa Universalis V/mod/Estates Pay Building Maintenance`

This EU5 mod makes estates pay for building maintenance. Buildings have maintenance costs defined as production method goods. The mod tracks these goods per-location using variable maps, prices them at market rates, and charges estates proportional to their power share. Crown power determines how much the crown pays vs estates (linear: 0% crown power = estates pay 100%, 100% crown power = crown pays 100%).

## Current Architecture (National-Level Distribution)

### How it works now

1. **Initialization** (`epbm_on_actions.txt`): On game start (and save-safe first pulse), iterates all locations and calls `epbm_initialize_location` which dispatches per-building init effects.

2. **Per-location variable map** (`epbm_maint`): Each location stores a `variable_map` keyed by goods references (e.g., `goods:stone`, `goods:tools`) with quantity values representing total maintenance goods needed at that location.

3. **PM hooks** (`epbm_generated_inject.txt` + `epbm_generated_pm_effects.txt`): 246 buildings have INJECT/REPLACE blocks adding `on_built`/`on_destroyed` hooks that call `epbm_add_X`/`epbm_remove_X` to update the location's variable map when buildings are built/destroyed. Generated by `tools/generate_building_hooks.py`.

4. **Monthly collection** (`epbm_effects.txt` → `epbm_collect_maintenance`):
   - Iterates `every_owned_location` with `has_variable_map = epbm_maint`
   - For each location, uses `every_key_in_variable_map` to sum `quantity * market_price` into `epbm_loc_total`
   - Accumulates all locations into `epbm_country_total`
   - Applies `estate_fraction = 1 - estate_power(estate_type:crown_estate)` (linear scaling)
   - Sums total non-crown estate power globally
   - Distributes to each non-crown estate proportional to their **global** estate power share
   - Calls `add_gold_to_estate` for each estate's share

5. **Crown estate scaling** (`epbm_crown_estate.txt`): INJECT into crown_estate with `building_upkeep_costs` modifiers that produce a linear -100% to 0% curve. Combined with `epbm_defines.txt` setting `BUILDING_UPKEEP_FACTOR = 1.0`.

6. **GUI** (`epbm_government_tooltips.gui`): Overrides `Estate_tooltip` template to show per-estate maintenance payment as a sub-item under expenses: "- From X% of Building Maintenance: -Y.YY gold"

### File listing

| File | Purpose |
|------|---------|
| `tools/generate_building_hooks.py` | Parses base game, generates 4 script files |
| `loading_screen/common/defines/epbm_defines.txt` | `BUILDING_UPKEEP_FACTOR = 1.0` |
| `in_game/common/estates/epbm_crown_estate.txt` | INJECT crown_estate with building_upkeep_costs scaling |
| `in_game/common/on_action/epbm_on_actions.txt` | Game start init, monthly player/yearly AI collection |
| `in_game/common/scripted_effects/epbm_effects.txt` | Core logic: init, accumulate, collect, distribute |
| `in_game/common/scripted_effects/epbm_generated_pm_effects.txt` | Per-PM add/remove effects (generated) |
| `in_game/common/scripted_effects/epbm_generated_init_effects.txt` | Per-building init + dispatch (generated) |
| `in_game/common/building_types/epbm_generated_inject.txt` | INJECT on_built/on_destroyed (generated, 244 buildings) |
| `in_game/common/building_types/epbm_generated_replace.txt` | REPLACE for monastery + bey_fortress (generated) |
| `in_game/common/scripted_triggers/epbm_triggers.txt` | `epbm_has_non_crown_estates` trigger |
| `in_game/common/script_values/epbm_values.txt` | `epbm_this_estate_global_power` value |
| `in_game/gui/shared/epbm_government_tooltips.gui` | Estate tooltip with maintenance display |
| `in_game/localization/english/epbm_gui_l_english.yml` | Localization overrides for estate economy info |

## Proposed Feature: Location-Based Distribution

### Goal

Instead of distributing maintenance costs globally (every estate pays the same share everywhere), distribute **per-location** based on each estate's local tax share at that location. This connects maintenance to control - estates in locations with low control already receive tax income from those locations, so they should also pay maintenance there.

### Key API findings

From the base game GUI and script:

- **`local_relative_estate_power(estate_ref)`** - trigger from **location scope**, returns 0-1 float of an estate's relative power at that location. This is the local equivalent of `estate_power()`.

- **`Location.GetEstateTaxBasePercent(Estate.Self)`** - GUI accessor showing each estate's tax base percentage at a location. Found in `peasant_enfranchisement`-related tooltips. This represents the share of local tax income going to each estate.

- **`local_estate_power`** - raw local estate power value from location scope (not normalized to 0-1).

- **`every_buildings_in_location`** - iterator already used in initialization.

- **`building_base_price`** - from building_type scope, the base construction cost.

### What needs to change

The key change is in `epbm_collect_maintenance` in `epbm_effects.txt`. Currently:

```
# Current flow:
for each location:
    sum goods * price → loc_total
    country_total += loc_total

estate_fraction = 1 - crown_power
country_total *= estate_fraction

for each non-crown estate:
    share = estate_power(this) / total_non_crown_power
    payment = country_total * share
    add_gold_to_estate(payment)
```

Proposed flow:

```
# New flow:
for each location:
    sum goods * price → loc_total
    loc_total *= estate_fraction  (still 1 - crown_power, global)

    for each non-crown estate:
        # Use LOCAL estate tax share instead of global power
        local_share = local_relative_estate_power(estate_type) / sum_local_non_crown_powers
        estate_accumulators[estate] += loc_total * local_share

for each non-crown estate:
    add_gold_to_estate(accumulated_total)
```

This means estates with more local presence (higher tax share) at locations with expensive buildings pay more. An estate that dominates a region with many buildings pays proportionally more maintenance for those buildings.

### Open questions

1. **Is `local_relative_estate_power` available as a script value (not just trigger)?** Need to verify it can be used in math expressions, not just conditions. If it's trigger-only, we may need to use `local_estate_power` and normalize manually.

2. **Performance**: The current approach is O(locations * goods). The new approach is O(locations * goods + locations * estates). Monthly for player, yearly for AI. Should be acceptable but worth testing.

3. **Per-estate accumulator variables**: Currently payment is computed in one pass. With per-location distribution, we need to accumulate across locations before making the single `add_gold_to_estate` call. Use local variables like `epbm_accum_nobles`, `epbm_accum_clergy`, etc. (or a variable map keyed by estate type if the API supports it).

4. **Control interaction**: Does `local_relative_estate_power` already account for control? If low control reduces estate presence, this naturally charges estates less for poorly-controlled locations. Need to verify.

### EU5 syntax reference

- `pdx-syntax` CLI tool for looking up effects, triggers, scopes, modifiers
- `pdx-format` must be run on all edited `.txt` and `.gui` files after changes
- Variable map API: see `variable_maps.md` in memory
- Base game path for searching: `/mnt/c/SteamLibrary/steamapps/common/Europa Universalis V`
- Do NOT search the user's Documents directory for base game files

### Key syntax patterns used in this mod

```pdx
# Variable map read
variable_map(epbm_maint|goods:stone)

# Variable map iterate
every_key_in_variable_map = { variable = epbm_maint ... }

# Market price from goods scope
price_in_market(scope:epbm_market)

# Estate power (global, from country scope)
estate_power(estate_type:crown_estate)

# Estate iteration
every_estate = {
    limit = { estate_type != estate_type:crown_estate }
    save_scope_as = current_estate
    owner = { ... }
}

# Pay estate
add_gold_to_estate = { estate_type = X value = Y }
```
